#!/bin/bash
set -euo pipefail

# Configuration
ENVIRONMENT="${1:-production}"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ARGOCD_VERSION="${ARGOCD_VERSION:-9.1.6}"
ARGOCD_NAMESPACE="${ARGOCD_NAMESPACE:-argocd}"
REPO_URL="${REPO_URL:-https://github.com/ProficientnowTech/pn-infra.git}"
REPO_TOKEN="${REPO_TOKEN:-}"

# Colors
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

log() { echo -e "${GREEN}[SUCCESS] [$(date +'%H:%M:%S')] [Argo Bootstrap] $1${NC}"; }
info() { echo -e "${BLUE}[INFO]    [$(date +'%H:%M:%S')] [Argo Bootstrap] $1${NC}"; }
warn() { echo -e "${YELLOW}[WARN]    [$(date +'%H:%M:%S')] [Argo Bootstrap] $1${NC}"; }
error() { echo -e "${RED}[ERROR]   [$(date +'%H:%M:%S')] [Argo Bootstrap] $1${NC}"; }

# Check prerequisites
check_prerequisites() {
	log "üîç Checking prerequisites..."
	command -v kubectl >/dev/null 2>&1 || {
		error "kubectl required but not installed"
		exit 1
	}
	command -v helm >/dev/null 2>&1 || {
		error "helm required but not installed"
		exit 1
	}
	kubectl cluster-info >/dev/null 2>&1 || {
		error "Cannot connect to cluster"
		exit 1
	}
	log "‚úì Prerequisites OK"
}

# Install ArgoCD
install_argocd() {
	log "üöÄ Installing ArgoCD..."

	# Ensure repo exists
	if ! helm repo list | grep -q "^argo\\s"; then
		helm repo add argo https://argoproj.github.io/argo-helm || {
			error "Failed to add Argo Helm repository"
			return 1
		}
	fi
	helm repo update >/dev/null 2>&1

	# üî• FIX: If argocd-notifications-secret exists but is NOT Helm-owned, patch it
	if kubectl get secret argocd-notifications-secret -n "${ARGOCD_NAMESPACE}" >/dev/null 2>&1; then
		owner_label=$(kubectl get secret argocd-notifications-secret -n "${ARGOCD_NAMESPACE}" -o jsonpath='{.metadata.labels.app\.kubernetes\.io/managed-by}' 2>/dev/null || echo "")
		release_name=$(kubectl get secret argocd-notifications-secret -n "${ARGOCD_NAMESPACE}" -o jsonpath='{.metadata.annotations.meta\.helm\.sh/release-name}' 2>/dev/null || echo "")

		if [[ "$owner_label" != "Helm" || "$release_name" != "argocd" ]]; then
			warn "‚ö†Ô∏è ArgoCD notifications secret exists but is not Helm-owned. Patching ownership..."

			kubectl label secret argocd-notifications-secret \
				app.kubernetes.io/managed-by=Helm --overwrite -n "${ARGOCD_NAMESPACE}" || {
				error "Failed to apply Helm ownership label"
				return 1
			}

			kubectl annotate secret argocd-notifications-secret \
				meta.helm.sh/release-name=argocd --overwrite -n "${ARGOCD_NAMESPACE}" || {
				error "Failed to apply Helm release-name annotation"
				return 1
			}

			kubectl annotate secret argocd-notifications-secret \
				meta.helm.sh/release-namespace="${ARGOCD_NAMESPACE}" --overwrite -n "${ARGOCD_NAMESPACE}" || {
				error "Failed to apply Helm release-namespace annotation"
				return 1
			}

			log "‚úì Patched secret ownership: Helm will now accept this resource"
		else
			log "‚úì argocd-notifications-secret already Helm-owned"
		fi
	fi

	# ---- Actual Helm install ----
	helm upgrade --install argocd argo/argo-cd \
		--version "${ARGOCD_VERSION}" \
		--namespace "${ARGOCD_NAMESPACE}" \
		--create-namespace \
		--set configs.cm.application.resourceTrackingMethod=annotation \
		--wait \
		--timeout=600s \
		2>&1 | tee /tmp/argocd-helm-install.log >/dev/null || {

		error "‚ùå Helm installation failed. See /tmp/argocd-helm-install.log"
		return 1
	}

	log "‚úì ArgoCD installed"
}

# Wait for ArgoCD to be fully ready
wait_for_argocd() {
	log "‚è≥ Waiting for ArgoCD to be ready..."

	# Wait for pods to be ready with kubectl wait (extended timeouts)
	log "‚è≥ Waiting for ArgoCD pods to be ready (timeout: 900s)..."
	kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-server -n ${ARGOCD_NAMESPACE} --timeout=900s >/dev/null 2>&1
	kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-application-controller -n ${ARGOCD_NAMESPACE} --timeout=900s >/dev/null 2>&1
	kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-repo-server -n ${ARGOCD_NAMESPACE} --timeout=900s >/dev/null 2>&1

	# Additional wait for services to be fully operational with 1-second intervals (extended timeout)
	log "‚è≥ Waiting for ArgoCD services to be operational (checking every second for 90 seconds)..."
	local max_attempts=90
	local attempt=1

	while [ $attempt -le $max_attempts ]; do
		# Get detailed pod status
		local pod_status=$(kubectl get pods -n ${ARGOCD_NAMESPACE} -l app.kubernetes.io/part-of=argocd -o jsonpath='{range .items[*]}{.metadata.name}: {.status.phase} {.status.containerStatuses[0].ready}{"\n"}{end}' 2>/dev/null || echo "No pods found")

		# Count ready pods
		local ready_pods=$(echo "$pod_status" | grep "true" | wc -l)
		local total_pods=$(echo "$pod_status" | grep -c ":" || echo "0")

		if [[ $ready_pods -eq $total_pods && $total_pods -gt 0 ]]; then
			log "‚úì All $total_pods ArgoCD pods ready and operational after $attempt seconds"
			break
		fi

		# Log detailed progress every time (1-second intervals)
		info "ArgoCD status [${attempt}/${max_attempts}]: $ready_pods/$total_pods pods ready"
		if [[ $attempt -eq 1 || $((attempt % 10)) -eq 0 ]]; then
			# Show detailed pod status every 10 attempts (less verbose)
			while IFS= read -r line; do
				if [[ -n "$line" ]]; then
					info "  - $line"
				fi
			done <<<"$pod_status"
		fi

		sleep 1
		((attempt++))
	done

	if [ $attempt -gt $max_attempts ]; then
		warn "‚ö†Ô∏è  ArgoCD services check timed out after ${max_attempts} seconds"
		warn "Current pod status:"
		kubectl get pods -n ${ARGOCD_NAMESPACE} -l app.kubernetes.io/part-of=argocd 2>/dev/null || warn "Cannot get pod status"
	else
		log "‚úì All ArgoCD pods confirmed ready"
	fi

	log "‚úì ArgoCD ready"
}

# Get ArgoCD admin password
get_argocd_password() {
	local max_attempts=60
	local attempt=1

	while [ $attempt -le $max_attempts ]; do
		# Try to get the password from the initial admin secret
		local password=$(kubectl get secret argocd-initial-admin-secret -n ${ARGOCD_NAMESPACE} -o jsonpath="{.data.password}" 2>/dev/null | base64 -d 2>/dev/null || echo "")

		if [[ -n "$password" ]]; then
			echo "$password"
			return 0
		fi

		# If we can't find the initial admin secret, try getting it from the argocd-secret
		if [[ $attempt -eq 5 ]]; then
			info "Trying alternative method to get ArgoCD password..."
			password=$(kubectl get secret argocd-secret -n ${ARGOCD_NAMESPACE} -o jsonpath="{.data.admin\.password}" 2>/dev/null | base64 -d 2>/dev/null || echo "")

			if [[ -n "$password" ]]; then
				echo "$password"
				return 0
			fi
		fi

		if [[ $attempt -eq 1 ]]; then
			info "Waiting for ArgoCD password to be generated..."
		elif [[ $((attempt % 5)) -eq 0 ]]; then
			info "Still waiting for ArgoCD password... (attempt $attempt/$max_attempts)"
		fi

		sleep 2
		((attempt++))
	done

	error "Failed to retrieve ArgoCD admin password after $max_attempts attempts"
	error "You may need to check the ArgoCD pods and secrets manually:"
	error "  kubectl get pods -n ${ARGOCD_NAMESPACE}"
	error "  kubectl get secrets -n ${ARGOCD_NAMESPACE} | grep admin"
	return 1
}

# Wait for user to manually add repository and confirm
print_argo_success() {
	local password=$(get_argocd_password || echo "not-found")

	echo
	echo -e "${BLUE}========= ArgoCD Installation Complete ==========="
	echo -e "=================================================${NC}"
	echo
	echo -e "${GREEN}===== ArgoCD is now installed and ready${NC}====="
	echo
	echo -e "${YELLOW} You could proceed with the following steps:${NC}"
	echo
	echo -e "1. ${BLUE}Start port-forward (in a separate terminal):${NC}"
	echo -e "   ${GREEN}kubectl port-forward --address 0.0.0.0,localhost svc/argocd-server -n ${ARGOCD_NAMESPACE} 8080:443${NC}"
	echo
	echo -e "2. ${BLUE}Access ArgoCD Dashboard:${NC}"
	echo -e "   ${GREEN}https://localhost:8080${NC}"
	echo
	echo -e "3. ${BLUE}Login with:${NC}"
	echo -e "   Username: ${GREEN}admin${NC}"
	echo -e "   Password: ${GREEN}${password}${NC}"
	echo
}

setup_argocd_notifications() {
	info "Setting up ArgoCD notifications (Slack + Email)..."

	# Check if notifications secret already exists
	if kubectl get secret -n argocd argocd-notifications-secret &>/dev/null; then
		log "ArgoCD notifications secret already exists"
		return 0
	fi

	echo
	info "üìß Setting up ArgoCD Notifications"
	echo "   This will configure Slack and email notifications for ArgoCD"
	echo

	# Prompt for Slack token
	local SLACK_TOKEN=""
	while true; do
		echo
		info "üîî Slack Bot Configuration"
		echo "   1. Create Slack app at: https://api.slack.com/apps"
		echo "   2. Add scopes: chat:write, chat:write.public, channels:read"
		echo "   3. Install app to workspace"
		echo "   4. Copy Bot User OAuth Token (xoxb-...)"
		echo
		read -r -s -p "Enter Slack Bot OAuth Token (or press Enter to skip): " SLACK_TOKEN
		echo

		if [[ -z "$SLACK_TOKEN" ]]; then
			warn "Skipping Slack notifications setup"
			break
		fi

		# Validate token format
		if [[ "$SLACK_TOKEN" =~ ^xoxb- ]]; then
			log "Slack token format validated"
			break
		else
			error "Invalid Slack token format (should start with xoxb-)"
			read -p "Try again? (Y/n): " -n 1 -r
			echo
			if [[ $REPLY =~ ^[Nn]$ ]]; then
				warn "Skipping Slack notifications setup"
				SLACK_TOKEN=""
				break
			fi
		fi
	done

	# Prompt for email configuration
	local EMAIL_PASSWORD=""
	local EMAIL_USERNAME="platform-admin@pnats.cloud"
	local EMAIL_HOST="mail.pnats.cloud"
	local EMAIL_PORT="587"

	while true; do
		echo
		info "üìß Email (SMTP) Configuration"
		echo "   Email: $EMAIL_USERNAME"
		echo "   SMTP Host: $EMAIL_HOST"
		echo "   SMTP Port: $EMAIL_PORT"
		echo
		read -r -s -p "Enter email password for $EMAIL_USERNAME (or press Enter to skip): " EMAIL_PASSWORD
		echo

		if [[ -z "$EMAIL_PASSWORD" ]]; then
			warn "Skipping email notifications setup"
			break
		fi

		log "Email password captured"
		break
	done

	# Check if at least one notification method is configured
	if [[ -z "$SLACK_TOKEN" && -z "$EMAIL_PASSWORD" ]]; then
		warn "No notification methods configured - skipping notifications secret creation"
		return 0
	fi

	# Create the notifications secret
	info "Creating ArgoCD notifications secret..."

	local secret_data=""
	if [[ -n "$SLACK_TOKEN" ]]; then
		secret_data="$secret_data --from-literal=slack-token=$SLACK_TOKEN"
	fi
	if [[ -n "$EMAIL_PASSWORD" ]]; then
		secret_data="$secret_data --from-literal=email-username=$EMAIL_USERNAME"
		secret_data="$secret_data --from-literal=email-password=$EMAIL_PASSWORD"
	fi

	if kubectl create secret generic argocd-notifications-secret \
		--namespace=argocd \
		$secret_data; then
		log "‚úì ArgoCD notifications secret created successfully"

		if [[ -n "$SLACK_TOKEN" ]]; then
			log "  ‚úì Slack notifications enabled"
		fi
		if [[ -n "$EMAIL_PASSWORD" ]]; then
			log "  ‚úì Email notifications enabled ($EMAIL_USERNAME)"
		fi

		echo
		info "üìù Next steps for notifications:"
		if [[ -n "$SLACK_TOKEN" ]]; then
			echo "   1. Create Slack channel: #platform-alerts"
			echo "   2. Invite bot: /invite @ArgoCD Notifications"
		fi
		echo "   3. Update values.yaml subscriptions if needed"
		echo
	else
		error "Failed to create ArgoCD notifications secret"
		return 1
	fi
}

setup_argocd_repository() {
	local repo_secret_file="${SCRIPT_DIR}/repositories/pn-infra.yaml"
	local temp_secret_file=""

	info "Setting up ArgoCD repository access via Kubernetes Secret..."

	# Check if repository secret already exists
	if kubectl get secret -n argocd pn-infra &>/dev/null; then
		log "Repository secret already exists in ArgoCD"
		return 0
	fi

	# Check if secret file exists
	if [[ ! -f "$repo_secret_file" ]]; then
		error "Repository secret file not found: $repo_secret_file"
		return 1
	fi

	# Check if REPO_TOKEN is already set from environment
	if [[ -z "$REPO_TOKEN" ]]; then
		# Prompt for GitHub token (masked input)
		echo
		info "üîë GitHub Token required for private repository access"
		echo "   Repository: https://github.com/ProficientnowTech/pn-infra.git"
		echo "   The token needs 'repo' scope permissions"
		echo
	else
		info "Using REPO_TOKEN from environment"
	fi

	while [[ -z "$REPO_TOKEN" ]]; do
		read -r -s -p "Enter your GitHub Personal Access Token (input hidden): " REPO_TOKEN
		echo

		if [[ -z "$REPO_TOKEN" ]]; then
			error "Token cannot be empty"
			continue
		fi
		break
	done

	# Validate token if provided
	if [[ -n "$REPO_TOKEN" ]]; then

		# Validate token against GitHub API
		info "Validating GitHub token..."
		local validation_result
		validation_result=$(curl -s -H "Authorization: Bearer $REPO_TOKEN" \
			-H "Accept: application/vnd.github.v3+json" \
			"https://api.github.com/user" 2>/dev/null | grep -E '"login"|"message"' || echo "invalid")

		if echo "$validation_result" | grep -q '"login"'; then
			local github_user
			github_user=$(echo "$validation_result" | grep '"login"' | cut -d'"' -f4)
			log "Token validated successfully! GitHub user: $github_user"
		elif echo "$validation_result" | grep -q '"message"'; then
			local error_msg
			error_msg=$(echo "$validation_result" | grep '"message"' | cut -d'"' -f4)
			warn "Token validation warning: $error_msg"
			warn "Proceeding with token anyway (may fail later)"
		else
			warn "Token validation failed: Cannot connect to GitHub API"
			warn "Proceeding with token anyway (may fail later)"
		fi
	fi

	# Create temporary file with actual token
	temp_secret_file=$(mktemp)
	sed "s/TOKEN_PLACEHOLDER/$REPO_TOKEN/g" "$repo_secret_file" >"$temp_secret_file"

	# Wait for ArgoCD namespace to be ready
	info "Waiting for ArgoCD components to be ready..."
	kubectl wait --for=condition=Ready pod -l app.kubernetes.io/name=argocd-server -n argocd --timeout=120s || {
		warn "ArgoCD server not fully ready, but continuing with repository setup..."
	}
	kubectl wait --for=condition=Ready pod -l app.kubernetes.io/name=argocd-application-controller -n argocd --timeout=120s || {
		warn "ArgoCD application controller not fully ready, but continuing with repository setup..."
	}
	kubectl wait --for=condition=Ready pod -l app.kubernetes.io/name=argocd-repo-server -n argocd --timeout=120s || {
		warn "ArgoCD repo server not fully ready, but continuing with repository setup..."
	}

	# Apply the repository secret
	info "Applying repository secret to ArgoCD..."
	if kubectl apply -f "$temp_secret_file"; then
		log "Repository secret successfully applied to ArgoCD"

		# Wait for repository connection
		info "Waiting for repository connection to be established..."
		local max_attempts=30
		local attempt=1

		while [[ $attempt -le $max_attempts ]]; do
			# Check if the secret has the ArgoCD repository label
			local secret_type=$(kubectl get secret -n argocd pn-infra -o json 2>/dev/null | jq -r '.metadata.labels["argocd.argoproj.io/secret-type"] // empty')

			if [[ "$secret_type" == "repository" ]]; then
				log "Repository connection established (secret labeled correctly)"
				# Clean up temporary file
				rm -f "$temp_secret_file"
				return 0
			fi

			if [[ $attempt -eq $max_attempts ]]; then
				warn "Repository secret applied but connection status unknown"
				info "ArgoCD should pick up the repository shortly"
				# Clean up temporary file
				rm -f "$temp_secret_file"
				return 0
			fi

			info "Waiting for repository connection... (attempt $attempt/$max_attempts)"
			sleep 2
			((attempt++))
		done

	else
		error "Failed to apply repository secret"
		rm -f "$temp_secret_file"
		return 1
	fi
}

# Main
main() {
	log "üöÄ Starting ArgoCD installation (${ENVIRONMENT})..."

	info "Note: Repository credentials and notifications are handled by sealed-secrets"
	info "      These secrets should be applied BEFORE running this script"

	check_prerequisites
	install_argocd
	wait_for_argocd

	# Verify that repository secret exists (created by sealed-secrets)
	if kubectl get secret -n argocd | grep -q "argocd-private-repo\|pn-infra"; then
		log "‚úì Repository credentials found (managed by sealed-secrets)"
	else
		warn "‚ö†Ô∏è Repository credentials not found in ArgoCD namespace"
		warn "   Make sure sealed-secrets are applied before deploying applications"
	fi

	print_argo_success

	log "‚úÖ ArgoCD installation completed!"
}

main "$@"
