---
# Vault Helm Chart Values following KubriX pattern
# Chart: https://helm.releases.hashicorp.com
# Version: 0.30.1

eso:
  enabled: true
  # Do not hardcode `.svc.cluster.local` because this cluster uses a custom DNS domain.
  providerUrl: "http://vault-active.vault.svc:8200"
  # Vault Enterprise namespaces (empty for OSS Vault)
  vaultNamespace: ""
  backendName: vault-backend
  mount: secret
  kubernetesAuth:
    mountPath: kubernetes
    role: external-secrets
    serviceAccountRef:
      name: external-secrets
      namespace: external-secrets

vault:
  injector:
    enabled: false

  server:
    ingress:
      enabled: true
      ingressClassName: nginx
      annotations:
        external-dns.alpha.kubernetes.io/ttl: "60"
        cert-manager.io/cluster-issuer: letsencrypt-production
      hosts:
      - host: vault.pnats.cloud
        paths: []
      tls:
      - secretName: vault-tls
        hosts:
        - vault.pnats.cloud

    extraInitContainers:
    - name: utility-downloader
      image: alpine/curl:latest
      command:
      - /bin/sh
      - -c
      - |
        cd /usr/local/libexec/vault
        curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
        chmod +x kubectl
        curl -L -o jq https://github.com/stedolan/jq/releases/download/jq-1.8.1/jq-linux64
        chmod +x jq
      volumeMounts:
      - name: plugins
        mountPath: /usr/local/libexec/vault
      securityContext:
        allowPrivilegeEscalation: false
        capabilities:
          drop:
          - ALL
        privileged: false
        runAsNonRoot: true

    extraContainers:
    - name: auto-initializer
      image: hashicorp/vault:1.20.3
      env:
      - name: VAULT_ADDR
        valueFrom:
          secretKeyRef:
            name: vault-env-vars
            key: VAULT_ADDR
      command:
      - /bin/sh
      - -c
      - |
        while true; do
          sleep 10
          while [ -z $UNSEAL_KEY ]; do
            sleep 5
            VAULT_STATUS=$(vault status)
            if echo "$VAULT_STATUS" | grep -q "Initialized.*false" && [ $HOSTNAME = 'vault-0' ]; then
              export INIT_RESPONSE=$(vault operator init -format=json -key-shares=1 -key-threshold=1)
              echo "$INIT_RESPONSE"
              export UNSEAL_KEY=$(echo "$INIT_RESPONSE" | /usr/local/libexec/vault/jq -r .unseal_keys_b64[0])
              export ROOT_TOKEN=$(echo "$INIT_RESPONSE" | /usr/local/libexec/vault/jq -r .root_token)
              echo "$UNSEAL_KEY"
              echo "$ROOT_TOKEN"
              /usr/local/libexec/vault/kubectl delete secret vault-init -n vault
              /usr/local/libexec/vault/kubectl create secret generic vault-init -n vault --from-literal=unseal_key=${UNSEAL_KEY} --from-literal=root_token=${ROOT_TOKEN} 
            else
              echo "Vault Initialized"
            fi 
          done   
        done
      volumeMounts:
      - name: plugins
        mountPath: /usr/local/libexec/vault
      securityContext:
        allowPrivilegeEscalation: false
        capabilities:
          drop:
          - ALL
        privileged: false
        runAsNonRoot: true

    - name: auto-unsealer
      image: hashicorp/vault:1.20.3
      env:
      - name: VAULT_ADDR
        valueFrom:
          secretKeyRef:
            name: vault-env-vars
            key: VAULT_ADDR
      command:
      - /bin/sh
      - -c
      - |
        while true; do
          sleep 10
          VAULT_STATUS=$(vault status)
          if echo "$VAULT_STATUS" | grep -q "Initialized.*false" && [ $HOSTNAME != 'vault-0' ]; then
            echo joining raft cluster
            vault operator raft join http://vault-0.vault-internal:8200
            sleep 5
          fi 
          if echo "$VAULT_STATUS" | grep -q "Initialized.*true"; then
            if echo "$VAULT_STATUS" | grep -q "Sealed.*true"; then
              if [ -f /vault-root-token/unseal_key ]; then
                vault operator unseal $(cat /vault-root-token/unseal_key)
                sleep 5
              else
                echo unseal key not initialized yet  
              fi
            else  
              echo vault already unsealed
            fi
          else  
            echo Vault not initialized yet
          fi
        done
      volumeMounts:
      - name: vault-root-token
        mountPath: /vault-root-token
      securityContext:
        allowPrivilegeEscalation: false
        capabilities:
          drop:
          - ALL
        privileged: false
        runAsNonRoot: true
    - name: vault-initializer
      image: hashicorp/vault:1.20.3
      env:
      - name: VAULT_ADDR
        valueFrom:
          secretKeyRef:
            name: vault-env-vars
            key: VAULT_ADDR
      command:
      - /bin/sh
      - -c
      - |
        while true; do
          sleep 10

          if [ -f /vault-root-token/root_token ]; then
            export VAULT_TOKEN="$(cat /vault-root-token/root_token)"

            if vault status | grep -q "Sealed.*false"; then
              # only run setup when admins group does NOT exist
              if ! vault read identity/group/name/admins >/dev/null 2>&1; then
                # kubernetes auth backend
                if ! vault read auth/kubernetes/config >/dev/null 2>&1; then
                  vault auth enable kubernetes || true
                  vault write auth/kubernetes/config \
                    token_reviewer_jwt="$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)" \
                    kubernetes_host="https://${KUBERNETES_PORT_443_TCP_ADDR:-$KUBERNETES_SERVICE_HOST}:443" \
                    kubernetes_ca_cert=@/var/run/secrets/kubernetes.io/serviceaccount/ca.crt
                fi

                # kv v2 secrets engine
                if ! vault secrets list | grep -q "^secret/"; then
                  vault secrets enable -path=secret kv-v2
                  echo "KV v2 secrets engine enabled at path 'secret'"
                fi

                # crossplane role
                if ! vault read auth/kubernetes/role/crossplane >/dev/null 2>&1; then
                  CROSSPLANETOKEN="$(vault token create -display-name=crossplane-token -policy=root -format=json \
                  | /usr/local/libexec/vault/jq -r '.auth.client_token')"
                  /usr/local/libexec/vault/kubectl create secret generic crossplane-init -n vault \
                    --from-literal=credentials='{"token":"'"$CROSSPLANETOKEN"'"}' || true

                  vault write auth/kubernetes/role/crossplane \
                    bound_service_account_names="*" \
                    bound_service_account_namespaces=crossplane \
                    policies=crossplane \
                    ttl=24h \
                    audience=crossplane
                fi

                # external-secrets operator policy and role
                # Allow ESO to both read secrets (ExternalSecret) and write secrets (PushSecret)
                # Scope to applications/ prefix and platform-data/ prefix for operator-managed secrets
                printf '%s\n' \
                  'path "secret/data/applications/*" {' \
                  '  capabilities = ["create", "update", "read", "list"]' \
                  '}' \
                  'path "secret/metadata/applications/*" {' \
                  '  capabilities = ["create", "update", "read", "list"]' \
                  '}' \
                  'path "secret/data/platform-data/*" {' \
                  '  capabilities = ["create", "update", "read", "list"]' \
                  '}' \
                  'path "secret/metadata/platform-data/*" {' \
                  '  capabilities = ["create", "update", "read", "list"]' \
                  '}' \
                  | vault policy write external-secrets-policy -
                echo "External Secrets Operator policy ensured"

                if ! vault read auth/kubernetes/role/external-secrets >/dev/null 2>&1; then
                  vault write auth/kubernetes/role/external-secrets \
                    bound_service_account_names=external-secrets \
                    bound_service_account_namespaces=external-secrets \
                    policies=external-secrets-policy \
                    ttl=1h
                  echo "External Secrets Operator role created"
                fi
              else
                echo "setup complete"
              fi
            else
              echo "vault still sealed"
            fi
          else
            echo "root token not initialized yet"
          fi
        done
      volumeMounts:
      - name: vault-root-token
        mountPath: /vault-root-token
      - name: plugins
        mountPath: /usr/local/libexec/vault
      securityContext:
        allowPrivilegeEscalation: false
        capabilities:
          drop:
          - ALL
        privileged: false
        runAsNonRoot: true

    # Readiness probe
    readinessProbe:
      enabled: true
      path: "/v1/sys/health?standbyok=true&sealedcode=204&uninitcode=204"

    # Liveness probe
    livenessProbe:
      enabled: true
      path: "/v1/sys/health?standbyok=true"
      initialDelaySeconds: 60

    # Audit storage
    auditStorage:
      enabled: true
      size: 10Gi
      storageClass: plt-blk-hdd-repl

    # Volumes and mounts
    volumes:
    - name: plugins
      emptyDir: {}
    - name: vault-root-token
      secret:
        secretName: vault-init
        optional: true
    volumeMounts:
    - mountPath: /usr/local/libexec/vault
      name: plugins
      readOnly: false
    # Data storage
    dataStorage:
      enabled: true
      size: 10Gi
      storageClass: plt-blk-hdd-repl # High Availability with Raft integrated storage

    ha:
      enabled: true
      replicas: 3
      raft:
        enabled: true
        setNodeId: true
        config: |
          ui = true

          listener "tcp" {
            tls_disable = 1
            address = "[::]:8200"
            cluster_address = "[::]:8201"
            # Enable unauthenticated metrics access (necessary for Prometheus Operator)
            telemetry {
              unauthenticated_metrics_access = "true"
            }
          }

          storage "raft" {
            path = "/vault/data"
          }

          # For integrated raft storage and security
          # https://developer.hashicorp.com/vault/docs/configuration#disable_mlock
          disable_mlock = true
          telemetry {
            prometheus_retention_time = "30m"
            disable_hostname = true
          }
          service_registration "kubernetes" {}
          plugin_directory = "/usr/local/libexec/vault"

  serverTelemetry:
    serviceMonitor:
      enabled: false
      interval: 30s
      scrapeTimeout: 10s

  prometheusRules:
    enabled: false
    rules:
      - alert: VaultSealed
        expr: vault_core_unsealed == 0
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "Vault is sealed"
          description: "Vault instance {{ $labels.instance }} is sealed and cannot serve requests"
      - alert: VaultDown
        expr: up{job="vault"} == 0
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "Vault is down"
          description: "Vault instance {{ $labels.instance }} is down"

  ui:
    enabled: true
    serviceType: ClusterIP

rootTokenSync:
  enabled: true
  sourceNamespace: vault
  sourceSecret: vault-init
  targetNamespace: crossplane-system
  targetSecret: vault-admin-token
  targetSecretKey: token
  serviceAccountName: vault-root-token-sync
  # Bitnami moved many images to the legacy registry path.
  image: docker.io/bitnamilegacy/kubectl:1.30.3

# Monitoring Configuration
monitoring:
  grafanaDashboard:
    enabled: true

crossplaneProvider:
  enabled: true
  # NOTE: provider-vault uses v2/v3 tags in xpkg (v0.x does not exist and 404s).
  package: xpkg.upbound.io/upbound/provider-vault:v3.0.3
  providerConfig:
    name: vault-admin
    # Do not hardcode `.svc.cluster.local` because this cluster uses a custom DNS domain.
    address: http://vault-active.vault.svc:8200
    skipTlsVerify: true
    credentialsSecret:
      namespace: crossplane-system
      name: vault-admin-token
      key: token
