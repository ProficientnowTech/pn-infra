---
# Example: Tenant Provisioning Automation
# This would be managed by a custom Kubernetes controller/operator

# Step 1: Tenant CRD (Custom Resource Definition)
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: tenants.multitenancy.platform.io
spec:
  group: multitenancy.platform.io
  names:
    kind: Tenant
    listKind: TenantList
    plural: tenants
    singular: tenant
  scope: Cluster
  versions:
    - name: v1alpha1
      served: true
      storage: true
      schema:
        openAPIV3Schema:
          type: object
          properties:
            spec:
              type: object
              properties:
                tenantId:
                  type: string
                  pattern: '^tenant-[0-9]{6}$'
                plan:
                  type: string
                  enum: [free, starter, professional, enterprise]
                tier:
                  type: string
                  enum: [small, medium, large, dedicated]
                maxStorage:
                  type: string
                  pattern: '^[0-9]+(Gi|Ti)$'
                maxConnections:
                  type: integer
                  minimum: 5
                  maximum: 1000
            status:
              type: object
              properties:
                phase:
                  type: string
                  enum: [Pending, Provisioning, Active, Migrating, Suspended, Terminated]
                clusterId:
                  type: string
                clusterNamespace:
                  type: string
                database:
                  type: string
                connectionString:
                  type: string
                createdAt:
                  type: string
                  format: date-time
                lastUpdated:
                  type: string
                  format: date-time
---
# Step 2: Example Tenant Resource
apiVersion: multitenancy.platform.io/v1alpha1
kind: Tenant
metadata:
  name: tenant-000001
spec:
  tenantId: "tenant-000001"
  plan: professional
  tier: medium  # Auto-assigned based on plan
  maxStorage: "10Gi"
  maxConnections: 50
---
# Step 3: Tenant Credentials Secret (created by controller)
apiVersion: v1
kind: Secret
metadata:
  name: tenant-000001-credentials
  namespace: mongodb-medium-tier
  labels:
    tenant-id: tenant-000001
    managed-by: tenant-controller
type: Opaque
stringData:
  username: "tenant_000001_user"
  password: "<auto-generated-strong-password>"
  connectionString: "mongodb://tenant_000001_user:<password>@medium-tenant-pool-01-rs0.mongodb-medium-tier.svc:27017/tenant_000001?ssl=true&replicaSet=rs0"
---
# Step 4: Update PerconaServerMongoDB to add user (via controller)
# The controller would patch the existing PerconaServerMongoDB CR
apiVersion: psmdb.percona.com/v1
kind: PerconaServerMongoDB
metadata:
  name: medium-tenant-pool-01
  namespace: mongodb-medium-tier
spec:
  # ... existing spec ...
  users:
    # Existing users...
    - name: admin
      db: admin
      passwordSecretRef:
        name: medium-pool-01-admin-password
        key: password
      roles:
        - name: clusterAdmin
          db: admin

    # New tenant user (added by controller)
    - name: tenant_000001_user
      db: tenant_000001
      passwordSecretRef:
        name: tenant-000001-credentials
        key: password
      roles:
        - name: dbOwner
          db: tenant_000001
      authenticationRestrictions:
        - clientSource:
            - "10.0.0.0/8"  # Internal network only

  # Custom role for tenant (prevents access to other DBs)
  roles:
    - role: tenant_000001_limited_role
      db: admin
      privileges:
        - resource:
            db: "tenant_000001"
            collection: ""
          actions:
            - find
            - insert
            - update
            - remove
            - createIndex
            - dropIndex
            - createCollection
            - dropCollection
            - listCollections
            - listIndexes
---
# Step 5: Tenant Registry Entry
# Stored in central MongoDB registry cluster
# Collection: tenants
{
  "_id": "tenant-000001",
  "tenantId": "tenant-000001",
  "plan": "professional",
  "tier": "medium",
  "status": "active",

  "cluster": {
    "id": "medium-tenant-pool-01",
    "namespace": "mongodb-medium-tier",
    "database": "tenant_000001",
    "connectionString": "mongodb://medium-tenant-pool-01-rs0.mongodb-medium-tier.svc:27017/tenant_000001?ssl=true&replicaSet=rs0"
  },

  "credentials": {
    "secretName": "tenant-000001-credentials",
    "secretNamespace": "mongodb-medium-tier"
  },

  "limits": {
    "maxStorageBytes": 10737418240,  // 10 GiB
    "maxConnections": 50,
    "maxOperationsPerSecond": 1000
  },

  "usage": {
    "storageBytes": 1073741824,  // 1 GiB currently used
    "activeConnections": 12,
    "averageOpsPerSecond": 150
  },

  "timestamps": {
    "createdAt": ISODate("2025-01-15T10:00:00Z"),
    "lastUpdated": ISODate("2025-01-15T12:30:00Z"),
    "lastAccessedAt": ISODate("2025-01-15T12:29:55Z")
  },

  "billing": {
    "subscriptionId": "sub_abc123",
    "billingCycle": "monthly",
    "nextBillingDate": ISODate("2025-02-15T00:00:00Z")
  }
}
---
# Step 6: Namespace ResourceQuota (prevents tenant resource abuse)
apiVersion: v1
kind: ResourceQuota
metadata:
  name: mongodb-medium-tier-quota
  namespace: mongodb-medium-tier
spec:
  hard:
    # Total resources for all clusters in this namespace
    requests.cpu: "60"
    requests.memory: 240Gi
    limits.cpu: "120"
    limits.memory: 480Gi
    persistentvolumeclaims: "50"
    pods: "100"
---
# Step 7: Network Policy (isolate MongoDB from other namespaces)
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: mongodb-medium-tier-policy
  namespace: mongodb-medium-tier
spec:
  podSelector:
    matchLabels:
      app.kubernetes.io/name: percona-server-mongodb
  policyTypes:
    - Ingress
    - Egress
  ingress:
    # Allow from application namespaces
    - from:
        - namespaceSelector:
            matchLabels:
              access-mongodb: "true"
      ports:
        - protocol: TCP
          port: 27017
    # Allow from monitoring
    - from:
        - namespaceSelector:
            matchLabels:
              name: monitoring
      ports:
        - protocol: TCP
          port: 9216  # MongoDB exporter
  egress:
    # Allow DNS
    - to:
        - namespaceSelector:
            matchLabels:
              name: kube-system
      ports:
        - protocol: UDP
          port: 53
    # Allow S3 for backups (adjust CIDR as needed)
    - to:
        - ipBlock:
            cidr: 0.0.0.0/0
      ports:
        - protocol: TCP
          port: 443
